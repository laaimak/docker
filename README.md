# Докеризация Python/Django приложения

## Цель лабораторной работы
Создать и запустить в Docker контейнере работоспособное Python/Django приложение с базой данных MySQL, следуя заданным требованиям.

---

## Условия для выполнения лабораторной работы

1. Образ должен быть легковесным.
2. Использовать базовые легковесные образы - Alpine.
3. Вся конфигурация приложения должна быть через переменные окружения.
4. Статика и зависимости должны быть вынесены во внешние тома `volume`.
5. Создать файл `docker-compose.yml` для старта и сборки приложения.
6. В `docker-compose.yml` нужно подключить базу данных.
7. При старте приложения должны автоматически выполняться миграции.
8. Контейнер приложения должен запускаться от непривилегированного пользователя.
9. После установки всех необходимых утилит должен очищаться кэш.

---

## Реализация лабораторной работы

### 1. Выбор приложения
Для реализации лабораторной работы было выбрало приложение TODO, которое помогает пользователям составлять расписание своих дел. 

### 2. Dockerfile
Для приложения был создан следующий `Dockerfile`:

```dockerfile
# Используем легковесный базовый образ Python. Он минимален, что уменьшает размер итогового контейнера
FROM python:3.11-alpine

# Устанавливаем рабочую директорию. Все команды, которые в дальнейшем будут запускаться, будут относиться к этой директории
WORKDIR /app

# Копируем весь проект. Так как мы создали рабочую директорию, необходимо скопировать в неё все файлы из директории на хосте
COPY . .

# Переменные окружения
ENV PYTHONDONTWRITEBYTECODE 1   #Отключает запись файлов с байткодом Python (*.pyc), чтобы сократить размер контейнера.
ENV PYTHONUNBUFFERED 1          #Включает вывод в реальном времени в логах, отключая буферизацию вывода Python.
ENV STATIC_ROOT /app/static     #Указывает директорию для статических файлов Django.

# Создаем непривилегированного пользователя. Это важно для безопасности, чтобы приложение не запускалось от имени суперпользователя
RUN addgroup -S appgroup && adduser -S appuser -G appgroup

# Установка зависимостей для mysqlclient
RUN apk add --no-cache \        #установка необходимых пакетов для работы с mysqlserver
    mariadb-dev \               #заголовочные файлы и бибилотеки для работы с MySQL
    gcc \                       #компиляторы и инструменты для сборки
    musl-dev \                  
    python3-dev \               
    pkgconfig && \              
    rm -rf /var/cache/apk/*     #удаление кэша установленных пакетов

# Создаем директорию для хранения статических файлов Django
RUN mkdir -p ${STATIC_ROOT}

#Скрипт ожидания бызы данных. Нужен для того, чтобы приложение не запускалось, пока база данных MySQL не станет доступной
COPY wait_for_mysql.sh /wait_for_mysql.sh
RUN chmod +x /wait_for_mysql.sh


# Копируем файл зависимостей в корень /app
COPY requirements.txt .

# Устанавливаем Python зависимости
RUN pip install --upgrade pip       #Обновляет менеджер пакетов Python до последней версии.
RUN pip install --no-cache-dir -r requirements.txt      #Устанавливает зависимости, указанные в requirements.txt. --no-cache-dir предотвращает создание кэша, чтобы уменьшить размер образа.

#Открытие порта для внешних подключений
EXPOSE 8000

# Запускаем команду по умолчанию
CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]
```


### 3. docker-compose.yml
Для запуска приложения и базы данных был создан `docker-compose.yml`. Файл включает описание двух сервисов: django_app и mysql_db.

### 4. Скрипт ожидания базы данных
Создан файл `wait_for_mysql.sh` для ожидания готовности MySQL.

### 5. Переменные окружения
Вся конфигурация приложения вынесена в переменные окружения и передается через `docker-compose.yml`:
- `DB_HOST`: адрес базы данных (MySQL).
- `DB_NAME`: имя базы данных.
- `DB_USER`: имя пользователя базы данных.
- `DB_PASSWORD`: пароль пользователя базы данных.

### 6. Непривилегированный пользователь
В контейнере создан пользователь `appuser`, от имени которого запускается приложение. Это повышает безопасность.

### 7. Удаление кэша
При установке зависимостей через `pip` удаляется кэш (`rm -rf /root/.cache`), чтобы уменьшить размер итогового образа.

## Итог
Нам удалось контейнеризировать приложение, которое соответствует всем условиям лабораторной.

